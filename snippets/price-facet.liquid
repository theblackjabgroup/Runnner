{%- liquid
  assign currency_symbol = cart.currency.symbol | default: '$'
  assign from_label = 'products.facets.from' | t | default: 'FROM'
  assign to_label = 'products.facets.to' | t | default: 'TO'
  assign reset_label = 'products.facets.clear_all' | t | default: 'CLEAR'
  assign min_price = filter.min_value.value | default: 0
  assign max_price = filter.max_value.value | default: filter.range_max
  assign range_min = filter.range_min | default: 0
  assign range_max = filter.range_max | default: 10000
-%}

<div class="price-facet-container {% if filter_type == 'mobile' %}mobile-price-facet{% endif %}">
  <!-- CLEAR button in top right -->
  <div class="price-facet-header">
    <span class="price-reset" onclick="resetPriceFilters(event)">{{ reset_label }}</span>
  </div>

  <!-- Price Range Slider -->
  <div class="price-slider-container">
    <div class="price-slider-track">
      <div class="price-slider-range" id="slider-range-{{ id_prefix }}"></div>
      <div class="price-slider-wrapper">
        <input
          type="range"
          class="price-slider-handle price-slider-min"
          id="slider-min-{{ id_prefix }}"
          min="{{ range_min }}"
          max="{{ range_max }}"
          value="{{ min_price }}"
          oninput="updatePriceSlider('{{ id_prefix }}', this)"
        >
        <input
          type="range"
          class="price-slider-handle price-slider-max"
          id="slider-max-{{ id_prefix }}"
          min="{{ range_min }}"
          max="{{ range_max }}"
          value="{{ max_price }}"
          oninput="updatePriceSlider('{{ id_prefix }}', this)"
        >
      </div>
    </div>
  </div>

  <!-- Price Input Fields -->
  <div class="price-facet-inputs">
    <div class="price-input-row">
      <div class="price-field">
        <input
          class="price-input price-input-min"
          name="{{ filter.min_value.param_name }}"
          id="{{ id_prefix }}{{ filter.label | escape }}-GTE"
          {%- if filter.min_value.value -%}
            value="{{ filter.min_value.value | money_without_currency | replace: ',', '' | split: '.' | first }}"
          {%- endif -%}
          type="number"
          step="1"
          inputmode="numeric"
          placeholder="{{ currency_symbol }} {{ from_label }}"
          onkeydown="handlePriceKeydown(event)"
          oninput="updatePriceFromInput('{{ id_prefix }}', this.value, 'min')"
        >
      </div>

      <span class="price-separator">-</span>

      <div class="price-field">
        <input
          class="price-input price-input-max"
          name="{{ filter.max_value.param_name }}"
          id="{{ id_prefix }}{{ filter.label | escape }}-LTE"
          {%- if filter.max_value.value -%}
            value="{{ filter.max_value.value | money_without_currency | replace: ',', '' | split: '.' | first }}"
          {%- endif -%}
          type="number"
          step="1"
          inputmode="numeric"
          placeholder="{{ currency_symbol }} {{ to_label }}"
          onkeydown="handlePriceKeydown(event)"
          oninput="updatePriceFromInput('{{ id_prefix }}', this.value, 'max')"
        >
      </div>
    </div>
  </div>
</div>

<style>
  .price-facet-container {
    background-color: white;
    border-radius: 6px;
    padding: 16px;
    width: 280px;
    position: relative;
    font-family: sans-serif;
  }

  .price-facet-header {
    display: flex;
    justify-content: flex-end;
    margin-bottom: 16px;
  }

  .price-reset {
    font-family: sans-serif;
    font-size: 12px;
    color: #000;
    text-decoration: underline;
    cursor: pointer;
    text-transform: uppercase;
    font-weight: normal;
    padding: 0;
    margin: 0;
    background: none;
    border: none;
  }

  /* Price Slider Styles - FIXED */
  .price-slider-container {
    margin-bottom: 16px;
    position: relative;
    height: 20px;
  }

  .price-slider-track {
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 4px;
    background-color: #ccc;
    border-radius: 2px;
    transform: translateY(-50%);
  }

  .price-slider-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .price-slider-range {
    position: absolute;
    height: 4px;
    background-color: #000;
    border-radius: 2px;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
    z-index: 1;
  }

  .price-slider-handle {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: transparent;
    pointer-events: none;
    -webkit-appearance: none;
    appearance: none;
    margin: 0;
    padding: 0;
  }

  /* Enable pointer events only on the thumb */
  .price-slider-handle::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background-color: #000;
    border: 2px solid #fff;
    border-radius: 0;
    cursor: pointer;
    pointer-events: auto;
    position: relative;
    z-index: 4;
  }

  .price-slider-handle::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background-color: #000;
    border: 2px solid #fff;
    border-radius: 0;
    cursor: pointer;
    pointer-events: auto;
    position: relative;
    z-index: 4;
  }

  /* Ensure both sliders are interactive */
  .price-slider-min {
    z-index: 3;
  }

  .price-slider-max {
    z-index: 2;
  }

  /* When min value is being adjusted, bring it to front */
  .price-slider-min:active,
  .price-slider-min:focus {
    z-index: 5;
  }

  .price-slider-max:active,
  .price-slider-max:focus {
    z-index: 5;
  }

  /* Price Input Fields */
  .price-facet-inputs {
    margin-bottom: 0;
  }

  .price-input-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .price-field {
    flex: 1;
    position: relative;
  }

  .price-input {
    width: 100%;
    height: 32px;
    padding: 8px 10px;
    border: 1px solid #000;
    border-radius: 4px;
    font-family: sans-serif;
    font-size: 12px;
    background-color: white;
    color: #000;
    box-sizing: border-box;
    outline: none;
    -moz-appearance: textfield; /* Remove arrows in Firefox */
  }

  /* Remove arrows in Chrome, Safari, Edge, Opera */
  .price-input::-webkit-outer-spin-button,
  .price-input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  .price-input:focus {
    outline: none;
    border-color: #000;
  }

  .price-input::placeholder {
    color: #999;
    opacity: 1;
    font-size: 12px;
  }

  .price-separator {
    font-family: sans-serif;
    font-size: 14px;
    color: #000;
    font-weight: normal;
    flex-shrink: 0;
  }

  /* Mobile Responsive */
  @media (max-width: 768px) {
    .price-facet-container {
      width: 100%;
      max-width: 300px;
    }

    .price-slider-container {
      margin-bottom: 12px;
    }

    .price-input-row {
      flex-direction: column;
      gap: 8px;
    }

    .price-separator {
      display: none;
    }
  }
</style>

<script>
  function resetPriceFilters(event) {
    event.preventDefault();

    const container = event.target.closest('.price-facet-container');
    if (!container) return;

    const minInput = container.querySelector('.price-input-min');
    const maxInput = container.querySelector('.price-input-max');
    const minSlider = container.querySelector('.price-slider-min');
    const maxSlider = container.querySelector('.price-slider-max');

    if (minInput) {
      minInput.value = '';
    }

    if (maxInput) {
      maxInput.value = '';
    }

    if (minSlider && maxSlider) {
      minSlider.value = minSlider.min;
      maxSlider.value = maxSlider.max;
      updateSliderRange(container);
    }

    // Trigger filter update
    clearTimeout(window.priceResetTimeout);
    window.priceResetTimeout = setTimeout(() => {
      triggerFilterUpdate();
    }, 100);
  }

  function handlePriceKeydown(event) {
    if (event.key === 'Enter') {
      event.preventDefault();
      triggerFilterUpdate();
    }
  }

  function updatePriceSlider(prefix, sliderElement) {
    const container = sliderElement.closest('.price-facet-container');
    const minSlider = container.querySelector('.price-slider-min');
    const maxSlider = container.querySelector('.price-slider-max');
    const minInput = container.querySelector('.price-input-min');
    const maxInput = container.querySelector('.price-input-max');

    let minVal = parseInt(minSlider.value);
    let maxVal = parseInt(maxSlider.value);

    // Ensure min doesn't exceed max
    if (minVal > maxVal) {
      const temp = maxVal;
      maxVal = minVal;
      minVal = temp;
      minSlider.value = minVal;
      maxSlider.value = maxVal;
    }

    // Update input fields
    minInput.value = minVal;
    maxInput.value = maxVal;

    // Update visual range
    updateSliderRange(container);

    // Apply filters via AJAX after a short delay
    clearTimeout(window.priceSliderTimeout);
    window.priceSliderTimeout = setTimeout(() => {
      triggerFilterUpdate();
    }, 500);
  }

  function updatePriceFromInput(prefix, value, type) {
    // Find the correct input element that triggered this function
    // Use the type parameter to determine which input field was changed
    const inputElement =
      type === 'min'
        ? document.querySelector(`#${prefix}Price-GTE, .price-input-min`)
        : document.querySelector(`#${prefix}Price-LTE, .price-input-max`);

    if (!inputElement) {
      console.error(`Input element not found for type: ${type}`);
      return;
    }

    const container = inputElement.closest('.price-facet-container');
    if (!container) {
      console.error('Price facet container not found');
      return;
    }

    const minSlider = container.querySelector('.price-slider-min');
    const maxSlider = container.querySelector('.price-slider-max');
    const minInput = container.querySelector('.price-input-min');
    const maxInput = container.querySelector('.price-input-max');

    if (!minSlider || !maxSlider) {
      console.error('Slider elements not found');
      return;
    }

    // Parse value, allowing 0 as valid input
    let numValue = parseInt(value);

    // If value is empty or invalid (but not 0), use default
    if (isNaN(numValue)) {
      numValue = parseInt(type === 'min' ? minSlider.min : maxSlider.max);
    }

    if (type === 'min') {
      // Allow min to equal max (removed -1 constraint)
      minSlider.value = Math.max(parseInt(minSlider.min), Math.min(numValue, parseInt(maxSlider.value)));
    } else {
      // Allow max to equal min (removed +1 constraint)
      maxSlider.value = Math.min(parseInt(maxSlider.max), Math.max(numValue, parseInt(minSlider.value)));
    }

    updateSliderRange(container);

    clearTimeout(window.priceInputTimeout);
    window.priceInputTimeout = setTimeout(() => {
      triggerFilterUpdate();
    }, 800);
  }

  function updateSliderRange(container) {
    const minSlider = container.querySelector('.price-slider-min');
    const maxSlider = container.querySelector('.price-slider-max');
    const rangeDisplay = container.querySelector('.price-slider-range');

    if (!minSlider || !maxSlider || !rangeDisplay) return;

    const min = parseInt(minSlider.min);
    const max = parseInt(minSlider.max);
    const minVal = parseInt(minSlider.value);
    const maxVal = parseInt(maxSlider.value);

    const leftPercent = ((minVal - min) / (max - min)) * 100;
    const rightPercent = ((maxVal - min) / (max - min)) * 100;

    rangeDisplay.style.left = leftPercent + '%';
    rangeDisplay.style.width = rightPercent - leftPercent + '%';
  }

  function triggerFilterUpdate() {
    // Check if global AJAX function exists first
    if (typeof window.applyFiltersAjax === 'function') {
      try {
        window.applyFiltersAjax();
        return;
      } catch (error) {
        console.error('Error calling applyFiltersAjax:', error);
        // Fall through to fallback implementation
      }
    }

    // Fallback implementation
    const form = document.getElementById('FacetFiltersForm') || document.getElementById('FacetFiltersFormMobile');
    if (!form) {
      console.error('Filter form not found - cannot apply filters');
      // Don't reload - it would lose user input
      // Instead, show an error message to the user

      // Remove any existing error messages first to prevent accumulation
      const existingErrors = document.querySelectorAll('.filter-error-message');
      existingErrors.forEach((msg) => msg.remove());

      const errorMsg = document.createElement('div');
      errorMsg.className = 'filter-error-message'; // Add class for cleanup
      errorMsg.style.cssText =
        'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #f44336; color: white; padding: 12px 24px; border-radius: 4px; z-index: 9999;';
      errorMsg.textContent = 'Unable to apply filters. Please refresh the page.';
      document.body.appendChild(errorMsg);
      setTimeout(() => errorMsg.remove(), 5000);
      return;
    }

    // Build query parameters from form
    const formData = new FormData(form);
    const params = new URLSearchParams();

    for (let [key, value] of formData.entries()) {
      // Include zero values (important for price filters starting at $0)
      // Only exclude truly empty values (empty strings, null, undefined)
      if (value !== '' && value !== null && value !== undefined) {
        params.append(key, value);
      }
    }

    const currentUrl = new URL(window.location);
    const newUrl = `${currentUrl.pathname}?${params.toString()}`;
    const currentScrollY = window.scrollY;

    // Update URL without reload
    window.history.pushState({}, '', newUrl);

    // Fetch new results
    fetch(newUrl, {
      method: 'GET',
      headers: {
        'X-Requested-With': 'XMLHttpRequest',
      },
    })
      .then((response) => response.text())
      .then((html) => {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        // Update product grid - use most specific selector first
        // Priority: specific ID > specific class > generic patterns
        const selectors = [
          '#ProductGridContainer', // Most common Shopify pattern
          '#product-grid', // Alternative common pattern
          '.product-grid-main', // Our custom pattern
          '.collection-product-grid', // Collection specific
          '.product-grid-container', // Generic container
          '.product-grid', // Generic grid (might match multiple)
        ];

        let updated = false;
        for (let selector of selectors) {
          const newGrid = doc.querySelector(selector);
          const currentGrid = document.querySelector(selector);

          if (newGrid && currentGrid) {
            // Verify this is actually a product grid container (not a nested element)
            const hasProducts = newGrid.querySelector(
              '[class*="product-card"], [class*="product-item"], .card-wrapper'
            );

            // Check if this is a known container ID (more reliable than substring check)
            const isKnownContainer =
              selector === '#ProductGridContainer' || selector === '#product-grid' || selector === '.product-grid-main';

            // Only update if:
            // 1. It's a known/trusted container selector AND it has products in the new content
            // 2. OR it's a generic selector but has products (validates it's the right element)
            if (isKnownContainer && hasProducts) {
              // Trusted container with products - safe to update
              currentGrid.innerHTML = newGrid.innerHTML;
              updated = true;
              console.log('Updated product grid using selector:', selector);
              break; // Stop at first valid match to avoid updating wrong elements
            } else if (!isKnownContainer && hasProducts) {
              // Generic selector - only update if it has products
              currentGrid.innerHTML = newGrid.innerHTML;
              updated = true;
              console.log('Updated product grid using selector:', selector);
              break;
            } else if (isKnownContainer && !hasProducts) {
              // Known container but no products in new content
              // This might be an empty results page - still update to show "no results"
              currentGrid.innerHTML = newGrid.innerHTML;
              updated = true;
              console.log('Updated product grid (empty results) using selector:', selector);
              break;
            }
            // If none of above conditions met, continue to next selector
          }
        }

        if (!updated) {
          console.warn(
            'Could not find product grid. Available IDs:',
            Array.from(doc.querySelectorAll('[id]'))
              .map((el) => el.id)
              .filter((id) => id.toLowerCase().includes('product'))
          );
        }

        // Update product count
        const newCount = doc.querySelector('.product-count, [class*="product-count"]');
        const currentCount = document.querySelector('.product-count, [class*="product-count"]');
        if (newCount && currentCount) {
          currentCount.innerHTML = newCount.innerHTML;
        }

        // Update active facets pills (but NOT the filter form itself)
        const newActiveFacets = doc.querySelector('.active-facets');
        const currentActiveFacets = document.querySelector('.active-facets');
        if (newActiveFacets && currentActiveFacets) {
          currentActiveFacets.innerHTML = newActiveFacets.innerHTML;
        }

        // Maintain scroll position
        window.scrollTo(0, currentScrollY);
      })
      .catch((error) => {
        console.error('Filter update failed:', error);
        // If AJAX fails, fall back to page reload
        window.location.href = newUrl;
      });
  }

  // Initialize slider ranges on page load
  document.addEventListener('DOMContentLoaded', function () {
    document.querySelectorAll('.price-facet-container').forEach((container) => {
      updateSliderRange(container);
    });
  });
</script>
